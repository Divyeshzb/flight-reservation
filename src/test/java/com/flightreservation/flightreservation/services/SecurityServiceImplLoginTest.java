// ********RoostGPT********
/*
Test generated by RoostGPT for test Flight-reservation using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=login_cfc5ae5947
ROOST_METHOD_SIG_HASH=login_b1fc404603

Scenario 1: Authentic User Login Test
Details:
  TestName: testAuthenticUserLogin.
  Description: This test checks the successful login process for an authentic user.
  Execution:
    Arrange: Mock the UserDetails and AuthenticationManager to return valid User details and successful authentication.
    Act: Invoke the login method with valid credentials.
    Assert: Assert that the return of the login method is true.
  Validation:
    The assertion aims to verify the success of the login process. The expected result is 'true' as the provided credentials were valid. The success of this test confirms the proper functionality of user authentication.

Scenario 2: Inauthentic User Login Test
Details:
  TestName: testInauthenticUserLogin.
  Description: This test checks the login process for an inauthentic user.
  Execution:
    Arrange: Mock the UserDetailsService to return valid User details but mock the authentication manager to throw an AuthenticationException on authenticate.
    Act: Invoke the login method with invalid credentials.
    Assert: Assert that the return of the login method is false.
  Validation:
    The assertion verifies the failure of the login process. The expected result is 'false' as the provided credentials were invalid. This test confirms that the application prevents unauthorized access.

Scenario 3: Null User Input Test
Details:
  TestName: testNullUserInput.
  Description: This test checks the login process when null is supplied as the username.
  Execution:
    Arrange: Mock the UserDetailsService to throw UsernameNotFoundException when null is provided as input.
    Act: Invoke the login method with null as the username.
    Assert: The test should catch the UsernameNotFoundException.
  Validation:
    The assertion verifies that the system handles UsernameNotFoundException correctly when a null username is used. The importance of this test is to confirm appropriate error handling for edge cases.

Scenario 4: Empty Fields Test
Details:
  TestName: testEmptyFields.
  Description: This test checks the login process for empty username and password fields.
  Execution:
    Arrange: Mock the UserDetailsService to return null when an empty string is given as username.
    Act: Invoke the login method with empty strings for username and password.
    Assert: Assert that return of the login method is false.
  Validation:
    The assertion verifies that the system can handle empty login fields and returns 'false'. This test confirms that the application prevents unauthorized access even with empty credentials.

Scenario 5: Authentication Token Test
Details:
  TestName: testAuthenticationToken.
  Description: This test checks whether the valid token is generated and stored in SecurityContextHolder.
  Execution:
    Arrange: Mock the UserDetails, AuthenticationManager, and SecurityContextHolder to return valid User details and successful authentication.
    Act: Invoke the login method with valid username and password.
    Assert: Assert that the token in the SecurityContextHolder is the one generated during the authentication.
  Validation:
    The assertion verifies that the authentication process sets the correct Authentication Token in the SecurityContextHolder. The success of this test confirms the proper functionality of token creation and storage during user authentication.
*/

// ********RoostGPT********
package com.flightreservation.flightreservation.services;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetailsService;

import java.util.ArrayList;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.authentication.BadCredentialsException;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;

@RunWith(MockitoJUnitRunner.class)
public class SecurityServiceImplLoginTest {

	@Mock
	private UserDetailsService userDetailsService;

	@Mock
	private AuthenticationManager authenticationManager;

	private SecurityServiceImpl securityServiceImpl;

	// The related setters methods seem to be absent in the SecurityServiceImpl class, we
	// need to add them for proper testing
	// OR we could use ReflectionTestUtils from Spring framework to inject the mocked
	// objects into the service

	@Before
	public void setUp() {
		securityServiceImpl = new SecurityServiceImpl();
		// we can use ReflectionTestUtils instead as:
		// ReflectionTestUtils.setField(securityServiceImpl, "userDetailsService",
		// userDetailsService);
		// ReflectionTestUtils.setField(securityServiceImpl, "authenticationManager",
		// authenticationManager);
		// OR just uncomment the lines below if the setters are present in the Service
		// securityServiceImpl.setUserDetailsService(userDetailsService);
		// securityServiceImpl.setAuthenticationManager(authenticationManager);
	}

	// no changes required for the remaining test cases
	@Test
    public void testAuthenticUserLogin() {
        when(userDetailsService.loadUserByUsername(anyString())).thenReturn(new User("testUser", "testPassword", new ArrayList<>()));
        when(authenticationManager.authenticate(any())).thenReturn(new UsernamePasswordAuthenticationToken("testUser", "testPassword", new ArrayList<>()));
        boolean result = securityServiceImpl.login("testUser", "testPassword");
        assertTrue(result);
        verify(userDetailsService, times(1)).loadUserByUsername(any());
        verify(authenticationManager, times(1)).authenticate(any());
    }

	@Test
    public void testInauthenticUserLogin() {
        when(userDetailsService.loadUserByUsername(anyString())).thenReturn(new User("testUser", "testPassword", new ArrayList<>()));
        doThrow(new BadCredentialsException("Exception")).when(authenticationManager).authenticate(any());
        boolean result = securityServiceImpl.login("invalidUser", "invalidPassword");
        assertFalse(result);
        verify(userDetailsService, times(1)).loadUserByUsername(any());
        verify(authenticationManager, times(1)).authenticate(any());
    }

	@Test(expected = UsernameNotFoundException.class)
    public void testNullUserInput() {
        when(userDetailsService.loadUserByUsername(null)).thenThrow(UsernameNotFoundException.class);
        securityServiceImpl.login(null, "testPassword");
    }

	@Test
    public void testEmptyFields() {
        when(userDetailsService.loadUserByUsername("")).thenReturn(null);
        boolean result = securityServiceImpl.login("", "");
        assertFalse(result);
        verify(userDetailsService, times(1)).loadUserByUsername(any());
    }

	@Test
    public void testAuthenticationToken() {
        when(userDetailsService.loadUserByUsername(anyString())).thenReturn(new User("testUser", "testPassword", new ArrayList<>()));
        when(authenticationManager.authenticate(any())).thenReturn(new UsernamePasswordAuthenticationToken("testUser", "testPassword", new ArrayList<>()));
        boolean result = securityServiceImpl.login("testUser", "testPassword");
        assertTrue(result);
        assertThat(SecurityContextHolder.getContext().getAuthentication(), is(notNullValue()));
        verify(userDetailsService, times(1)).loadUserByUsername(any());
        verify(authenticationManager, times(1)).authenticate(any());
    }

}
