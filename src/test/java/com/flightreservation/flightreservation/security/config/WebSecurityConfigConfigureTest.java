
// ********RoostGPT********
/*
Test generated by RoostGPT for test flight-reservation-dm using AI Type  and AI Model

ROOST_METHOD_HASH=configure_15cb00d899
ROOST_METHOD_SIG_HASH=configure_4fd0d0b869

Here are some JUnit test scenarios for the `configure` method in the `WebSecurityConfig` entity:

Scenario 1: Verify Public URLs are Accessible Without Authentication

Details:
  TestName: publicUrlsAccessibleWithoutAuthentication
  Description: This test verifies that the public URLs ("/showReg", "/", "/index.html", "/registerUser", "/login", "/showLogin", "/login/*") are accessible without authentication.
Execution:
  Arrange: Set up the `HttpSecurity` mock and the necessary request matchers.
  Act: Invoke the `configure` method with the `HttpSecurity` mock.
  Assert: Verify that the public URLs are configured to permit all requests using `MockMvcRequestBuilders` and `MockMvcResultMatchers`.
Validation:
  The assertion ensures that the public URLs are accessible without requiring authentication.
  This test is important to validate that users can access the registration, login, and home pages without being authenticated.

Scenario 2: Verify Static Resource URLs are Accessible Without Authentication

Details:
  TestName: staticResourceUrlsAccessibleWithoutAuthentication
  Description: This test verifies that the static resource URLs ("/css/**", "/lib/**", "/images/**", "/js/**") are accessible without authentication.
Execution:
  Arrange: Set up the `HttpSecurity` mock and the necessary request matchers.
  Act: Invoke the `configure` method with the `HttpSecurity` mock.
  Assert: Verify that the static resource URLs are configured to permit all requests using `MockMvcRequestBuilders` and `MockMvcResultMatchers`.
Validation:
  The assertion ensures that the static resource URLs are accessible without requiring authentication.
  This test is important to validate that static resources like CSS, JavaScript, and images can be loaded without authentication.

Scenario 3: Verify Admin URLs Require ADMIN Authority

Details:
  TestName: adminUrlsRequireAdminAuthority
  Description: This test verifies that the admin URLs ("/admin/showAddFlight", "/admin/admin/addFlight", "/admin/*") require the "ADMIN" authority.
Execution:
  Arrange: Set up the `HttpSecurity` mock and the necessary request matchers.
  Act: Invoke the `configure` method with the `HttpSecurity` mock.
  Assert: Verify that the admin URLs are configured to require the "ADMIN" authority using `MockMvcRequestBuilders` and `MockMvcResultMatchers`.
Validation:
  The assertion ensures that only users with the "ADMIN" authority can access the admin URLs.
  This test is important to validate that administrative functionalities are restricted to users with the appropriate authority.

Scenario 4: Verify Other URLs Require Authentication

Details:
  TestName: otherUrlsRequireAuthentication
  Description: This test verifies that URLs other than the public and static resource URLs require authentication.
Execution:
  Arrange: Set up the `HttpSecurity` mock and the necessary request matchers.
  Act: Invoke the `configure` method with the `HttpSecurity` mock.
  Assert: Verify that other URLs are configured to require authentication using `MockMvcRequestBuilders` and `MockMvcResultMatchers`.
Validation:
  The assertion ensures that URLs not explicitly specified as public or static resources require authentication.
  This test is important to validate that protected resources are only accessible to authenticated users.

Scenario 5: Verify CSRF Protection is Disabled

Details:
  TestName: csrfProtectionDisabled
  Description: This test verifies that CSRF protection is disabled in the security configuration.
Execution:
  Arrange: Set up the `HttpSecurity` mock.
  Act: Invoke the `configure` method with the `HttpSecurity` mock.
  Assert: Verify that the `csrf().disable()` method is called on the `HttpSecurity` object.
Validation:
  The assertion ensures that CSRF protection is explicitly disabled in the security configuration.
  This test is important to validate that the application is not relying on CSRF tokens for protection against cross-site request forgery attacks.

Note: The actual implementation of these test scenarios would require the use of Spring Security's testing framework and mocking libraries like Mockito to set up the necessary mocks and perform the assertions.
*/

// ********RoostGPT********

package com.flightreservation.flightreservation.security.config;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

@WebMvcTest(WebSecurityConfig.class)
class WebSecurityConfigConfigureTest {

	@Autowired
	private MockMvc mockMvc;

	@MockBean
	private WebSecurityConfig webSecurityConfig;

	@Test
	@Tag("valid")
	void publicUrlsAccessibleWithoutAuthentication() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/showReg")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/index.html")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/registerUser")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/login")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/showLogin")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/login/test")).andExpect(MockMvcResultMatchers.status().isOk());
	}

	@Test
	@Tag("valid")
	void staticResourceUrlsAccessibleWithoutAuthentication() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/css/style.css")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/lib/jquery.js")).andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/images/logo.png"))
			.andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/js/script.js")).andExpect(MockMvcResultMatchers.status().isOk());
	}

	@Test
	@Tag("valid")
	@WithMockUser(authorities = "ADMIN")
	void adminUrlsRequireAdminAuthority() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/showAddFlight"))
			.andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/admin/addFlight"))
			.andExpect(MockMvcResultMatchers.status().isOk());
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/test")).andExpect(MockMvcResultMatchers.status().isOk());
	}

	@Test
	@Tag("invalid")
	@WithMockUser(authorities = "USER")
	void adminUrlsAccessDeniedForNonAdminAuthority() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/showAddFlight"))
			.andExpect(MockMvcResultMatchers.status().isForbidden());
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/admin/addFlight"))
			.andExpect(MockMvcResultMatchers.status().isForbidden());
		mockMvc.perform(MockMvcRequestBuilders.get("/admin/test"))
			.andExpect(MockMvcResultMatchers.status().isForbidden());
	}

	@Test
	@Tag("invalid")
	void otherUrlsRequireAuthentication() throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/protected"))
			.andExpect(MockMvcResultMatchers.status().isUnauthorized());
	}

	@Test
	@Tag("boundary")
	void csrfProtectionDisabled() throws Exception {
		HttpSecurity httpSecurity = mock(HttpSecurity.class);
		when(httpSecurity.authorizeRequests()).thenReturn(mock(HttpSecurity.class));
		webSecurityConfig.configure(httpSecurity);
		verify(httpSecurity).csrf().disable();
	}

}